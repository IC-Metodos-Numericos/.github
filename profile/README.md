# 🧠 Métodos Numéricos: Paradigmas Imperativo vs Funcional

Bem-vindo à organização de Iniciação Científica dedicada à análise e comparação de **métodos numéricos** implementados sob diferentes paradigmas de programação: **imperativo** (como C/Java/Python) e **funcional** (com foco em Haskell).

Este projeto visa estudar como os paradigmas influenciam a clareza, desempenho e manutenibilidade de algoritmos numéricos clássicos.

---

## 🎯 Objetivos

- Comparar a implementação de algoritmos numéricos sob os paradigmas imperativo e funcional.
- Avaliar aspectos como:
  - Legibilidade e expressividade do código
  - Eficiência computacional (tempo e espaço)
  - Facilidade de paralelização e abstração
- Promover o aprendizado prático em **Haskell** e linguagens imperativas (como Python/C/Java).

---

## 📚 Tópicos Abordados

- Resolução de sistemas lineares (ex: método de Gauss-Jordan)
- Aproximação de raízes (ex: método de Newton-Raphson)
- Integração numérica (ex: método dos trapézios, Simpson)
- Interpolação e ajuste de curvas
- Análise de erros e estabilidade numérica

---

## 🛠️ Estrutura dos Repositórios

Cada sub-repositório da organização contém:

- ✅ Implementações nos dois paradigmas
- 📊 Comparações de desempenho (benchmarking)
- 📖 Relatórios e análises teóricas
- 📎 Código comentado e modularizado

---

## 💻 Tecnologias Utilizadas

| Paradigma       | Linguagem        | Ferramentas e Recursos      |
|-----------------|------------------|------------------------------|
| Imperativo      | Python, C, Java  | NumPy, matplotlib, gcc       |
| Funcional       | Haskell          | GHC, Hoogle, Stack/Cabal     |

---

## 👥 Equipe


---

## 📄 Licença

Este projeto é licenciado sob a [MIT License](LICENSE).

---

> “Comparar algoritmos é fácil. Difícil é entender como o paradigma molda nosso modo de pensar.” – Desconhecido


<!--

# 🧠 Métodos Numéricos: Paradigmas Imperativo vs Funcional

Bem-vindo à organização de Iniciação Científica dedicada à análise e comparação de **métodos numéricos** implementados sob diferentes paradigmas de programação: **imperativo** (como C/Java/Python) e **funcional** (com foco em Haskell).

Este projeto visa estudar como os paradigmas influenciam a clareza, desempenho e manutenibilidade de algoritmos numéricos clássicos.

---

## 🎯 Objetivos

- Comparar a implementação de algoritmos numéricos sob os paradigmas imperativo e funcional.
- Avaliar aspectos como:
  - Legibilidade e expressividade do código
  - Eficiência computacional (tempo e espaço)
  - Facilidade de paralelização e abstração
- Promover o aprendizado prático em **Haskell** e linguagens imperativas (como Python/C/Java).

---

## 📚 Tópicos Abordados

- Resolução de sistemas lineares (ex: método de Gauss-Jordan)
- Aproximação de raízes (ex: método de Newton-Raphson)
- Integração numérica (ex: método dos trapézios, Simpson)
- Interpolação e ajuste de curvas
- Análise de erros e estabilidade numérica

---

## 🛠️ Estrutura dos Repositórios

Cada sub-repositório da organização contém:

- ✅ Implementações nos dois paradigmas
- 📊 Comparações de desempenho (benchmarking)
- 📖 Relatórios e análises teóricas
- 📎 Código comentado e modularizado

---

## 💻 Tecnologias Utilizadas

| Paradigma       | Linguagem        | Ferramentas e Recursos      |
|-----------------|------------------|------------------------------|
| Imperativo      | Python, C, Java  | NumPy, matplotlib, gcc       |
| Funcional       | Haskell          | GHC, Hoogle, Stack/Cabal     |

---

## 👥 Equipe

Este projeto é conduzido por alunos de graduação em Ciência da Computação com orientação de professores da área de métodos numéricos e linguagens de programação.

---

## 🤝 Contribuições

Contribuições são bem-vindas! Se você deseja participar ou colaborar com comparações, novos algoritmos ou melhorias, sinta-se à vontade para entrar em contato ou abrir um pull request em qualquer repositório.

---

## 📄 Licença

Este projeto é licenciado sob a [MIT License](LICENSE).

---

> “Comparar algoritmos é fácil. Difícil é entender como o paradigma molda nosso modo de pensar.” – Desconhecido

-->
